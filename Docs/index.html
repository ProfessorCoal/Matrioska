<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Matrioska  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="Matrioska  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">Matrioska Docs</a> (100% documented)</p>
        <p class="header-right"><a href="https://hopefully.soon.com"><img src="img/gh.png"/>View on GitHub</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">Matrioska Reference</a>
        <img id="carat" src="img/carat.png" />
        Matrioska  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Enums.html">Enums</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/ClusterLayout.html">ClusterLayout</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ClusterLayout/StackConfig.html">– StackConfig</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ClusterLayout/TabConfig.html">– TabConfig</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/ClusterLayout/TabBarConfig.html">– TabBarConfig</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/Component.html">Component</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Protocols/ComponentMeta.html">ComponentMeta</a>
              </li>
              <li class="nav-group-task">
                <a href="Protocols/MaterializableComponentMeta.html">MaterializableComponentMeta</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Structs.html">Structs</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Structs/ZipMeta.html">ZipMeta</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Subscripts.html">Subscripts</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Subscripts.html#/s:iE9MatrioskaVs10Dictionary9subscriptFSSGSqP__">subscript(_:)</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <a href='#matrioska' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h1 id='matrioska'>Matrioska</h1>

<blockquote>
<p>Matrioska let you create your layout and define the content of your app in a simple way.  </p>
</blockquote>

<ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a>

<ul>
<li><a href="#standard-components">Standard Components</a></li>
<li><a href="#meta">Meta</a></li>
<li><a href="#componentmeta">ComponentMeta</a></li>
<li><a href="#materializablecomponentmeta">MaterializableComponentMeta</a></li>
<li><a href="#creating-components">Creating Components</a></li>
<li><a href="#layout">Layout</a></li>
</ul></li>
<li><a href="#roadmap">Roadmap</a></li>
</ul>

<p>The vision of Matrioska is to let you build and prototype your app easily, reusing views and layouts, dynamically define the content of your app.
With Matrioska you can go as far as specifing the content and layout of your views from an external source (e.g. JSON).
With this power you can easily change the structure of your app, do A/B testing, staged rollout or prototype.</p>

<p>To build your UI you can use nested <code>Component</code>s. A <code>Component</code> can be 3 different things:</p>

<ul>
<li><strong>View</strong>: Any <code>UIViewController</code> that can use AutoLayout to specify its <code>intrinsicContentSize</code></li>
<li><strong>Cluster</strong>: Views with children (other <code>Component</code>s). A cluster is responsible of laying out its children’s views. Since a cluster is itself a view it can also contain other clusters.</li>
<li><strong>Wrapper</strong>: A View with only one child (a <code>Component</code>). You can see it as a special cluster or as a special view. It’s responsible to display its child’s view.</li>
</ul>

<p>The goal is to provide a tiny, but powerful foundation to build your app on top of it.
Matrioska will contain a limited set of standard components and we will consider to add more on a case by case basis.<br>
It’s really easy to extend Matrioska to add new components that fits your needs (TODO hamburger example).</p>
<a href='#installation' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='installation'>Installation</h2>

<p>Using <a href="http://cocoapods.org/">CocoaPods</a>:</p>
<pre class="highlight ruby"><code><span class="n">use_frameworks!</span>
<span class="n">pod</span> <span class="err">‘</span><span class="no">Matrioska</span><span class="err">’</span>
</code></pre>

<p>Using <a href="https://github.com/Carthage/Carthage">Carthage</a>:</p>
<pre class="highlight plaintext"><code>github “runtastic/Matrioska”
</code></pre>
<a href='#usage' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='usage'>Usage</h2>
<a href='#standard-components' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='standard-components'>Standard Components</h3>

<p>Matrioska defines some standard <code>Component</code>s that can be used to create your layout:</p>

<table><thead>
<tr>
<th>id</th>
<th>usage</th>
<th>config</th>
</tr>
</thead><tbody>
<tr>
<td>tabbar</td>
<td><code>ClusterLayout.tabBar(children, meta)</code></td>
<td><code>TabBarConfig</code> and <code>TabConfig</code> (children)</td>
</tr>
<tr>
<td>stack</td>
<td><code>ClusterLayout.stack(children, meta)</code></td>
<td><code>StackConfig</code></td>
</tr>
</tbody></table>

<p>See the documentation for more informations.</p>
<a href='#meta' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='meta'>Meta</h3>

<p>Every <code>Component</code> may handle additional metadata. The <code>Component</code>’s meta is optional and the <code>Component</code> is responsible to handle it correctlty. Metadata can be anything from configuration or additional information, for example a view controller title.</p>
<a href='#componentmeta' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='componentmeta'>ComponentMeta</h4>

<p>Every meta have to conform to <code>ComponentMeta</code> a simple protocol that provides a keyed (String) subscript.<br>
<code>ComponentMeta</code> provides a default implementation of a subscript that uses reflection (<code>Swift.Mirror</code>) to mirror the object and use its properties names and values. Object that conform to this protocol can eventually override this behavior.<br>
<code>ZipMeta</code> for example is a simple meta wrapper that aggregates multiple metas together, see its documentation and implementation for more info.
<code>Dictionary</code> also conforms to <code>ComponentMeta</code>, this is a convenient way to provide meta but is especially useful to materialize a <code>ComponentMeta</code> coming from a json/dictionary.</p>
<a href='#materializablecomponentmeta' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h4 id='materializablecomponentmeta'>MaterializableComponentMeta</h4>

<p>When creating a new <code>Component</code> you should document which kind of meta it expects. A good way to do this is to also create an object that represents the <code>Component</code>’s meta (e.g. see <code>StackConfig</code>) and make it conform to <code>ComponentMeta</code>.<br>
<code>MaterializableComponentMeta</code> however provides some more convenience methods that let you load your components from a json or materialize a meta from a dictionary.<br>
Other than <code>ComponentMeta</code>’s requirements you also need to provide a <code>init?(meta: ComponentMeta)</code>, then you can materialize any compatible meta into your own <code>MaterializableComponentMeta</code>.  </p>

<p>Example:</p>
<pre class="highlight swift"><code><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">MyConfig</span><span class="p">:</span> <span class="kt">MaterializableComponentMeta</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">let</span> <span class="nv">title</span><span class="p">:</span> <span class="kt">String</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">?(</span><span class="nv">meta</span><span class="p">:</span> <span class="kt">ComponentMeta</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">title</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s">"title"</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">String</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>After defining <code>MyConfig</code> we can materialize it from other <code>ComponentMeta</code>s if possible:</p>
<pre class="highlight swift"><code><span class="kt">MyConfig</span><span class="o">.</span><span class="nf">materialize</span><span class="p">([</span><span class="err">“</span><span class="n">title</span><span class="err">”</span><span class="p">:</span> <span class="err">“</span><span class="n">foo</span><span class="err">”</span><span class="p">])</span> <span class="c1">// MyConfig(title: "foo")</span>
<span class="kt">MyConfig</span><span class="o">.</span><span class="nf">materialize</span><span class="p">([</span><span class="err">“</span><span class="n">foo</span><span class="err">”</span><span class="p">:</span> <span class="err">“</span><span class="n">foo</span><span class="err">”</span><span class="p">])</span> <span class="c1">// nil</span>
<span class="kt">MyConfig</span><span class="o">.</span><span class="nf">materialize</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span> <span class="c1">// nil</span>
<span class="kt">MyConfig</span><span class="o">.</span><span class="nf">materialize</span><span class="p">(</span><span class="n">anotherMyConfigInstance</span><span class="p">)</span> <span class="c1">// anotherMyConfigInstance</span>
</code></pre>
<a href='#creating-components' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='creating-components'>Creating Components</h3>

<p>Create custom components:</p>
<pre class="highlight swift"><code><span class="c1">// Create a cluster by extending an existing implementation</span>
<span class="kd">extension</span> <span class="kt">UITabBarController</span> <span class="p">{</span>
    <span class="n">convenience</span> <span class="nf">init</span><span class="p">(</span><span class="nv">children</span><span class="p">:</span> <span class="p">[</span><span class="kt">Component</span><span class="p">],</span> <span class="nv">meta</span><span class="p">:</span> <span class="kt">Any</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">viewControllers</span> <span class="o">=</span> <span class="n">children</span><span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">viewController</span><span class="p">()</span> <span class="p">}</span>
        <span class="c1">// handle meta</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Any UIViewController can be used as a View</span>
<span class="c1">// we can define a convenience init or just use an inline closure to build the ViewController</span>
<span class="kd">class</span> <span class="kt">MyViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">meta</span><span class="p">:</span> <span class="kt">Any</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">guard</span> <span class="k">let</span> <span class="nv">meta</span> <span class="o">=</span> <span class="n">meta</span> <span class="k">as?</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Any</span><span class="p">]</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
        <span class="k">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s">"title"</span><span class="p">]</span> <span class="k">as?</span> <span class="kt">String</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Then create models that can be easily used to create the entire tree of views:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">component</span> <span class="o">=</span> <span class="kt">Component</span><span class="o">.</span><span class="nf">cluster</span><span class="p">(</span><span class="nv">builder</span><span class="p">:</span> <span class="kt">UITabBarController</span><span class="o">.</span><span class="kd">init</span><span class="p">,</span> <span class="nv">children</span><span class="p">:</span> <span class="p">[</span>
    <span class="kt">Component</span><span class="o">.</span><span class="nf">view</span><span class="p">(</span><span class="nv">builder</span><span class="p">:</span> <span class="kt">MyViewController</span><span class="o">.</span><span class="kd">init</span><span class="p">,</span> <span class="nv">meta</span><span class="p">:</span> <span class="p">[</span><span class="s">"title"</span><span class="p">:</span> <span class="s">"tab1"</span><span class="p">]),</span>
    <span class="kt">Component</span><span class="o">.</span><span class="nf">view</span><span class="p">(</span><span class="nv">builder</span><span class="p">:</span> <span class="p">{</span> <span class="n">_</span> <span class="k">in</span> <span class="kt">UIViewController</span><span class="p">()</span> <span class="p">},</span> <span class="nv">meta</span><span class="p">:</span> <span class="kc">nil</span><span class="p">),</span>
    <span class="p">],</span> <span class="nv">meta</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>

<span class="n">window</span><span class="o">.</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="nf">viewController</span><span class="p">()</span>
</code></pre>
<pre class="highlight swift"><code><span class="c1">// TODO: json, schema, factories, etc....</span>
</code></pre>
<a href='#layout' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h3 id='layout'>Layout</h3>

<p>Views are responsible to define their <code>intrinsicContentSize</code> using AutoLayout, cluster can decide to respect or respect not their dimensions, both vertical and horizontal or also only one of the two.
To make sure the a <code>Component</code>’s <code>UIViewController</code>has a valid <code>intrinsicContentSize</code> you need to add appropriate constraints to the view. <a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/ViewswithIntrinsicContentSize.html">To know more about this read the documentation about “Views with Intrinsic Content Size”</a>.</p>
<a href='#roadmap' class='anchor' aria-hidden=true><span class="header-anchor"></span></a><h2 id='roadmap'>Roadmap</h2>

<p>// TODO: &hellip;</p>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2016 <a class="link" href="https://github.com/runtastic/Matrioska" target="_blank" rel="external">Runtastic GmbH</a>. All rights reserved. (Last updated: 2016-11-24)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.7.2</a>, a <a class="link" href="http://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
